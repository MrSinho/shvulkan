<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>shvulkan: Clear Color Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<!--DOXYGEN AWESOME CSS-->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
  <script type="text/javascript">
    DoxygenAwesomeTabs.init()
</script>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">shvulkan<span id="projectnumber">&#160;pre-release</span>
   </div>
   <div id="projectbrief">by mrsinho.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_src_2clear__color__example.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Clear Color Example </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md15"></a></p>
<p><img src="https://img.shields.io/badge/shvulkan%20|%20SINHO%20SOFTWORKS-3CFADC?style=for-the-badge&amp;logo=&amp;logoColor=white&amp;labelColor=990042" alt="" class="inline"/> <a href="https://github.com/mrsinho/shvulkan"><img src="https://img.shields.io/badge/GitHub_repository-3CFADC?style=for-the-badge&amp;logo=github&amp;logoColor=black" alt="" class="inline"/></a></p>
<p>Setting up a Vulkan application involves several critical steps to ensure proper configuration and resource management for rendering. <a href="https://github.com/MrSinho/shvulkan/blob/main/examples/src/graphics/clear-color.c">This example (<span class="tt">shvulkan-clear-color</span>)</a> outlines the process from instance creation to frame presentation, integrating the various components and their roles.</p>
<p><img src="../media/clear_color_green.png" alt="" class="inline"/></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Instance and Surface Creation</h2>
<p>The Vulkan setup begins with creating a Vulkan instance using the <span class="tt">shCreateInstance</span> function. This step establishes the connection between the application and the Vulkan library, specifying the application and engine names, enabling validation layers for debugging, and defining required extensions and API versions. Following the instance creation, a window surface is created via <span class="tt">glfwCreateWindowSurface</span>. This surface allows Vulkan to render content to a window, interfacing directly with the windowing system.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Physical Device and Queue Setup</h2>
<p>Once the instance and surface are ready, the next step is selecting a suitable physical device (GPU). This is accomplished through <span class="tt">shSelectPhysicalDevice</span>, which evaluates the GPU's capabilities to ensure it supports the necessary operations for graphics, compute, and transfer. The function retrieves important details about the device, including its properties, features, and memory attributes.</p>
<p>Subsequently, the <span class="tt">shGetPhysicalDeviceQueueFamilies</span> function identifies the queue families supported by the device. These queues are critical for managing rendering, presentation, compute, and transfer tasks. Based on the indices retrieved for graphics and presentation queues, device queue creation is handled by <span class="tt">shQueryForDeviceQueueInfo</span>, which sets up the appropriate VkDeviceQueueCreateInfo structures.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Logical Device and Queues</h2>
<p>With the queue information in hand, <span class="tt">shSetLogicalDevice</span> creates the logical device. This device acts as an abstraction layer over the physical GPU, allowing the application to submit commands and manage resources. The logical device is configured with the necessary extensions and queue information to support the application's needs. Once the logical device is created, <span class="tt">shGetDeviceQueues</span> retrieves the actual queues for graphics and presentation, ensuring that commands can be submitted and images presented as required.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Swapchain and Command Buffers</h2>
<p>The swapchain is created using <span class="tt">shCreateSwapchain</span>, which manages the presentation of images to the screen. This process involves specifying the format, the number of images, and the sharing mode. The swapchain is essential for rendering content and displaying it on the window surface.</p>
<p>To manage command execution, <span class="tt">shCreateCommandPool</span> establishes command pools for graphics and potentially presentation tasks. Command buffers are then allocated with shAllocateCommandBuffers, which are used to record rendering commands. If the graphics and presentation queue families are different, separate command pools are created; otherwise, the same pool is used for both tasks.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Synchronization and Resources</h2>
<p>Synchronization between command submissions and image presentation is handled by <span class="tt">shCreateFences</span>, which creates fences to signal when commands are complete. <span class="tt">shGetSwapchainImages</span> retrieves the images from the swapchain, and <span class="tt">shCreateImageView</span> creates image views for these swapchain images, defining how they are accessed during rendering.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Renderpass and Framebuffers</h2>
<p>The setup concludes with the creation of a renderpass and associated framebuffers. <span class="tt">shCombineMaxSamples</span> determines the maximum number of samples for anti-aliasing. <span class="tt">shCreateRenderpass</span> configures the renderpass, defining attachments, subpasses, and their layouts. Finally, <span class="tt">shCreateFramebuffer</span> creates framebuffers for each swapchain image, linking them with the renderpass to facilitate rendering to the screen.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Main Loop Analysis</h2>
<p>The main loop of a Vulkan application is a critical section that manages rendering and presentation. It continuously updates the window content and handles various events. Here’s a breakdown of the process:</p>
<ul>
<li><b>Event Handling and Window Resize</b>. At the start of each loop iteration, the function <span class="tt">glfwPollEvents</span> is called to process any pending events, such as user inputs or window system events. Following this, the window size is queried with <span class="tt">glfwGetWindowSize</span>. If the window is not minimized (i.e., width and height are non-zero), the loop checks if the window has been resized. If so, it invokes resizeWindow to reconfigure the swapchain, surface, and related resources to match the new dimensions. This function updates the swapchain and other resources to ensure they align with the current window size and aspect ratio. The swapchain_image_idx is reset to 0 to start using the new swapchain images. Additionally, if the swapchain has become suboptimal (e.g., due to the window size change or other factors affecting performance), resizeWindow is called again to address these issues and restore optimal performance.</li>
<li><b>Synchronization and Command Buffer Management</b>. Once the window is properly resized, the loop proceeds to handle synchronization and command submission. It begins by creating a semaphore (current_image_acquired_semaphore) for signaling when the image from the swapchain is acquired. <span class="tt">shAcquireSwapchainImage</span> is then called to acquire an image from the swapchain. This function also checks if the swapchain is suboptimal and updates the swapchain_image_idx to point to the acquired image. The loop then waits for fences associated with the command buffers of the currently acquired image to ensure that previous commands have finished execution. This is achieved through <span class="tt">shWaitForFences</span>, followed by resetting the fences with <span class="tt">shResetFences</span> to prepare them for the next frame.</li>
<li><b>Command Recording and Rendering</b>. The command buffer for the current image is started using <span class="tt">shBeginCommandBuffer</span>. Rendering commands are recorded into this command buffer, starting with clearing the framebuffer. The clear color is dynamically calculated based on the current time, creating a visually dynamic effect. The renderpass is then initiated with <span class="tt">shBeginRenderpass</span>, specifying the clear values and the framebuffer. After recording the rendering commands, the renderpass is ended with <span class="tt">shEndRenderpass</span>, and the command buffer is finalized with <span class="tt">shEndCommandBuffer</span>.</li>
<li><b>Queue Submission and Presentation</b>. The completed command buffer is submitted to the graphics queue using shQueueSubmit. This function specifies the command buffer, waits for the acquisition semaphore, and signals another semaphore (graphics_queue_finished_semaphores) when the command execution is complete. After submission, the <span class="tt">shQueuePresentSwapchainImage</span> function presents the rendered image to the screen using the presentation queue. It waits for the graphics queue semaphore to ensure that rendering is completed before presenting the image.</li>
<li><b>Cleanup</b>. Finally, the temporary semaphore (<span class="tt">current_image_acquired_semaphore</span>) is destroyed to free up resources.</li>
</ul>
<p><img src="../media/clear_color_green.png" alt="" class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
