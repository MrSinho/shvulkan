\chapter{Clear Color Example}
\hypertarget{md_src_2clear__color__example}{}\label{md_src_2clear__color__example}\index{Clear Color Example@{Clear Color Example}}
\label{md_src_2clear__color__example_autotoc_md15}%
\Hypertarget{md_src_2clear__color__example_autotoc_md15}%


 \href{https://github.com/mrsinho/shvulkan}{\texttt{ }}

Setting up a Vulkan application involves several critical steps to ensure proper configuration and resource management for rendering. \href{https://github.com/MrSinho/shvulkan/blob/main/examples/src/graphics/clear-color.c}{\texttt{ This example ({\ttfamily shvulkan-\/clear-\/color})}} outlines the process from instance creation to frame presentation, integrating the various components and their roles.

\hypertarget{md_src_2clear__color__example_autotoc_md16}{}\doxysubsection{\texorpdfstring{Instance and Surface Creation}{Instance and Surface Creation}}\label{md_src_2clear__color__example_autotoc_md16}
The Vulkan setup begins with creating a Vulkan instance using the {\ttfamily sh\+Create\+Instance} function. This step establishes the connection between the application and the Vulkan library, specifying the application and engine names, enabling validation layers for debugging, and defining required extensions and API versions. Following the instance creation, a window surface is created via {\ttfamily glfw\+Create\+Window\+Surface}. This surface allows Vulkan to render content to a window, interfacing directly with the windowing system.\hypertarget{md_src_2clear__color__example_autotoc_md17}{}\doxysubsection{\texorpdfstring{Physical Device and Queue Setup}{Physical Device and Queue Setup}}\label{md_src_2clear__color__example_autotoc_md17}
Once the instance and surface are ready, the next step is selecting a suitable physical device (GPU). This is accomplished through {\ttfamily sh\+Select\+Physical\+Device}, which evaluates the GPU\textquotesingle{}s capabilities to ensure it supports the necessary operations for graphics, compute, and transfer. The function retrieves important details about the device, including its properties, features, and memory attributes.

Subsequently, the {\ttfamily sh\+Get\+Physical\+Device\+Queue\+Families} function identifies the queue families supported by the device. These queues are critical for managing rendering, presentation, compute, and transfer tasks. Based on the indices retrieved for graphics and presentation queues, device queue creation is handled by {\ttfamily sh\+Query\+For\+Device\+Queue\+Info}, which sets up the appropriate Vk\+Device\+Queue\+Create\+Info structures.\hypertarget{md_src_2clear__color__example_autotoc_md18}{}\doxysubsection{\texorpdfstring{Logical Device and Queues}{Logical Device and Queues}}\label{md_src_2clear__color__example_autotoc_md18}
With the queue information in hand, {\ttfamily sh\+Set\+Logical\+Device} creates the logical device. This device acts as an abstraction layer over the physical GPU, allowing the application to submit commands and manage resources. The logical device is configured with the necessary extensions and queue information to support the application\textquotesingle{}s needs. Once the logical device is created, {\ttfamily sh\+Get\+Device\+Queues} retrieves the actual queues for graphics and presentation, ensuring that commands can be submitted and images presented as required.\hypertarget{md_src_2clear__color__example_autotoc_md19}{}\doxysubsection{\texorpdfstring{Swapchain and Command Buffers}{Swapchain and Command Buffers}}\label{md_src_2clear__color__example_autotoc_md19}
The swapchain is created using {\ttfamily sh\+Create\+Swapchain}, which manages the presentation of images to the screen. This process involves specifying the format, the number of images, and the sharing mode. The swapchain is essential for rendering content and displaying it on the window surface.

To manage command execution, {\ttfamily sh\+Create\+Command\+Pool} establishes command pools for graphics and potentially presentation tasks. Command buffers are then allocated with sh\+Allocate\+Command\+Buffers, which are used to record rendering commands. If the graphics and presentation queue families are different, separate command pools are created; otherwise, the same pool is used for both tasks.\hypertarget{md_src_2clear__color__example_autotoc_md20}{}\doxysubsection{\texorpdfstring{Synchronization and Resources}{Synchronization and Resources}}\label{md_src_2clear__color__example_autotoc_md20}
Synchronization between command submissions and image presentation is handled by {\ttfamily sh\+Create\+Fences}, which creates fences to signal when commands are complete. {\ttfamily sh\+Get\+Swapchain\+Images} retrieves the images from the swapchain, and {\ttfamily sh\+Create\+Image\+View} creates image views for these swapchain images, defining how they are accessed during rendering.\hypertarget{md_src_2clear__color__example_autotoc_md21}{}\doxysubsection{\texorpdfstring{Renderpass and Framebuffers}{Renderpass and Framebuffers}}\label{md_src_2clear__color__example_autotoc_md21}
The setup concludes with the creation of a renderpass and associated framebuffers. {\ttfamily sh\+Combine\+Max\+Samples} determines the maximum number of samples for anti-\/aliasing. {\ttfamily sh\+Create\+Renderpass} configures the renderpass, defining attachments, subpasses, and their layouts. Finally, {\ttfamily sh\+Create\+Framebuffer} creates framebuffers for each swapchain image, linking them with the renderpass to facilitate rendering to the screen.\hypertarget{md_src_2clear__color__example_autotoc_md22}{}\doxysubsection{\texorpdfstring{Main Loop Analysis}{Main Loop Analysis}}\label{md_src_2clear__color__example_autotoc_md22}
The main loop of a Vulkan application is a critical section that manages rendering and presentation. It continuously updates the window content and handles various events. Hereâ€™s a breakdown of the process\+:


\begin{DoxyItemize}
\item {\bfseries{Event Handling and Window Resize}}. At the start of each loop iteration, the function {\ttfamily glfw\+Poll\+Events} is called to process any pending events, such as user inputs or window system events. Following this, the window size is queried with {\ttfamily glfw\+Get\+Window\+Size}. If the window is not minimized (i.\+e., width and height are non-\/zero), the loop checks if the window has been resized. If so, it invokes resize\+Window to reconfigure the swapchain, surface, and related resources to match the new dimensions. This function updates the swapchain and other resources to ensure they align with the current window size and aspect ratio. The swapchain\+\_\+image\+\_\+idx is reset to 0 to start using the new swapchain images. Additionally, if the swapchain has become suboptimal (e.\+g., due to the window size change or other factors affecting performance), resize\+Window is called again to address these issues and restore optimal performance.
\item {\bfseries{Synchronization and Command Buffer Management}}. Once the window is properly resized, the loop proceeds to handle synchronization and command submission. It begins by creating a semaphore (current\+\_\+image\+\_\+acquired\+\_\+semaphore) for signaling when the image from the swapchain is acquired. {\ttfamily sh\+Acquire\+Swapchain\+Image} is then called to acquire an image from the swapchain. This function also checks if the swapchain is suboptimal and updates the swapchain\+\_\+image\+\_\+idx to point to the acquired image. The loop then waits for fences associated with the command buffers of the currently acquired image to ensure that previous commands have finished execution. This is achieved through {\ttfamily sh\+Wait\+For\+Fences}, followed by resetting the fences with {\ttfamily sh\+Reset\+Fences} to prepare them for the next frame.
\item {\bfseries{Command Recording and Rendering}}. The command buffer for the current image is started using {\ttfamily sh\+Begin\+Command\+Buffer}. Rendering commands are recorded into this command buffer, starting with clearing the framebuffer. The clear color is dynamically calculated based on the current time, creating a visually dynamic effect. The renderpass is then initiated with {\ttfamily sh\+Begin\+Renderpass}, specifying the clear values and the framebuffer. After recording the rendering commands, the renderpass is ended with {\ttfamily sh\+End\+Renderpass}, and the command buffer is finalized with {\ttfamily sh\+End\+Command\+Buffer}.
\item {\bfseries{Queue Submission and Presentation}}. The completed command buffer is submitted to the graphics queue using sh\+Queue\+Submit. This function specifies the command buffer, waits for the acquisition semaphore, and signals another semaphore (graphics\+\_\+queue\+\_\+finished\+\_\+semaphores) when the command execution is complete. After submission, the {\ttfamily sh\+Queue\+Present\+Swapchain\+Image} function presents the rendered image to the screen using the presentation queue. It waits for the graphics queue semaphore to ensure that rendering is completed before presenting the image.
\item {\bfseries{Cleanup}}. Finally, the temporary semaphore ({\ttfamily current\+\_\+image\+\_\+acquired\+\_\+semaphore}) is destroyed to free up resources.
\end{DoxyItemize}

 